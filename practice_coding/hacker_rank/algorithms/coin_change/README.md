## Problem
[Coin Change](https://www.hackerrank.com/challenges/coin-change/problem)

## Notes
* [제출 코드](Solution.java)
    * 동전 조합이 unique해야하는 거라 점화식을 세우는 데에 엄청 애먹었고, 실제로도 구글링으로 시간을 엄청 허비했다
    * DP 풀 때 Memoization만 알았었는데, Tabulation은 처음이다
        * 같은 점 : 배열에 값을 연산 결과를 저장해서 중복 연산 대신 배열을 참조함
        * 다른 점
            * Memoization : 배열 참조했는데 값이 저장되어있지 않을 때마다, 즉 필요할 때마다 연산함
            * Tabulation : 모든 연산을 차례대로 다 함
    * 점화식
        * [f(동전 종류), 합]이 한 단위라고 생각하자
        * [f(), n]이면 무조건 0
        * [f(c, ...), 0]이면 무조건 1
            * '모든 동전을 주지 않는 경우'가 있으니까
        * [f(동전 종류), 합] = 마지막 종류의 동전(cm)을 사용하지 않고 합(n)을 만족하는 경우 + 마지막 종류의 동전(cm)으로 n - cm을 만족하는 경우
            * [f(c1), n] = [f(), n] + [f(c1), n - c1]
                * 이 때 k - c1이 0 미만인 경우는 0
            * [f(c1, c2), n] = [f(c1), n] + [f(c1, c2), n - c2]
    * tabulation한 결과를 저장하는 이차원 배열
        * 예시 : c는 {2, 5, 3, 6}이고 n은 6
            | |f(2)|f(2, 5)|f(2, 5, 3)|f(2, 5, 3, 6)|
            |------|:---------:|:---------:|:---------:|:---------:|
            |n = 0|1|1|1|1|
            |n = 1|0 + 0 = 0|t[1][0] + 0 = 0|t[1][1] + 0 = 0|t[1][2] + 0 = 0|
            |n = 2|0 + t[2 - 2][0] = 1| t[2][0] + 0 = 1|t[2][1] + 0 = 1|t[2][2] + 0 = 1|
            |n = 3|0 + 0 = 0|t[3][0] + 0 = 0|t[3][1] + t[3 - 3][2] = 1|t[3][2] + 0 = 1|
            |n = 4|0 + t[4 - 2][0] = 1|t[4][0] + 0 = 1|t[4][1] + t[4 - 3][2]  = 1|t[4][2] + 0 = 1|
            |n = 5|0 + t[5 - 2][0] = 0|t[5][0] + t[5 - 5][1] = 1|t[5][1] + t[5 - 3][2]  = 2|t[5][2] + 0 = 2|
            |n = 6|0 + t[6 - 2][0] = 1|t[6][0] + t[6 - 5][1] = 1|t[6][1] + t[6 - 3][2]  = 2|t[6][2] + t[6 - 6][3] = 3|
    * 왜 동전 종류를 Long으로 파싱했는지는 모르겠는데... index로 사용할 때 불편해서 int로 다시 파싱한 배열을 사용함